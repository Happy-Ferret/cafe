@doc prelude.md

;; prelude
;; =======
;; import this if you want anything to work
;; --

;; ## Symbols
;; ##### `*standard-output*`
;; global symbol bound to the stdout stream
;; --
(set! *standard-output* (io.output))

;; ##### `*version*`
;; global symbol bound to the Lua version currently in use, and the semver version of the compiler itself
;; --
(set! *version* (string.format "%s - %s" _VERSION "Café v0.2.0"))

;; ## Functions

;; ##### `exit-on-error! erfmt ...`
;; exits with a formatted error message and status code 1.
;; --
(defn (exit-with-error! erfmt ...)
	(print (string.format erfmt ...))
	(os.exit 1))

;; ##### `prompt pstr predicate?`
;; prompt the user for input, writing `pstr` before reading,
;; tests given input against `pred`, exiting with status
;; code -1 on failure.
;; --
(defn (prompt pchr pred)
	(io.write pchr)
	(let ((ret (io.read)))
		(if pred
			(if (not (pred ret))
				(exit-with-error! "Doesn't pass predicate!")
				ret)
			ret)))

;; ##### `print! stream string`
;; print a string to a stream
;; --
(defn (print! stream something)
	(let ((choose-stream (λ (s) (if s s (io.output)))))
		(let ((stream (choose-stream stream)))
			(.stream write something "\n"))))

;; ##### `print! stream fmtstr va_args`
;; print a formatted string to a stream
;; --
(defn (print-formatted! stream fmtstr ...)
	(print! stream (.fmtstr format ...)))

;; #### `format! fmtstr va_args`
;; print a formatted string to *standard-output* unconditionally
;; --
(defn (format! fmtstr ...)
	(print-formatted! *standard-output* fmtstr ...))

;; ##### `require! module`
;; require a Lua module into the current environment
;;
;; support for hot-compilation of café modules will be added at a later date.
;; --
(defn (require! module)
	(lua-raw "local ok, mod = pcall(require, module); if not ok then return false, 'no such module' .. module else for k, v in pairs(mod) do _G[string.format('__%s47%s__', module, k)] = v end end return mod"))

;; ##### `cons list elem`
;; cons an element in front of a list
;; --
(defn (cons car cdr)
	(list car cdr))

;; ##### `head list`
;; return the first element of a list
;; --
(defn (head list)
	(if list
		list[1]
		nil))

;; ##### `list`
;; create a list from given values
;; --
(defn (list ...) {...})

;; ##### `push! car rest`
;; insert a value at the head of a list, mutating it.
;; --
(defn (push-head! car rest)
	(table.insert rest 1 car)
	rest)

;; ##### `push-tail! end rest`
;; insert a value at the end of a list, mutating it.
;; --
(defn (push-tail! fin rest)
	(table.insert rest fin)
	rest)

;; ##### `tail list`
;; return the rest of the list, without head
;; --
(defn (tail l)
	(let ((ret (list)))
		(for i 2 (# l)
			(push-tail! l[i] ret))
		ret))

;; ##### `map list fn`
;; modify a list using a function, returning a new list
;; --
(defn (map li fn)
	(let ((ret (list)))
		(for i 1 (# li)
			(push-tail! (fn (nth i li)) ret))
		ret))

;; ##### `size li`
;; determine the size of a list.
;; --
(defn (size li)
	(let ((size 0))
		(map li (λ ()
			(set! size (+ 1 size) !global)))))

;; ##### `filter list fn`
;; filter a list using a predicate.
;; --
(defn (filter li fn)
	(let ((ret (list)))
		(for i 1 (# li)
			(if (truth? (fn (nth i li)))
				(push-tail! (nth i li) ret)))
		ret))

;; ##### `curry fna fnb`
;; merge two functions together
;; --

(defn (curry a b)
	(λ (...)
		(b (a ...))))

;; ##### `exists thing`
;; returns false if:
;; - thing is a table or a string and thing.length is 0
;; - thing is falsy (false, nil)
;;
;; if not, returns true.
;; --
(defn (exists? n)
	(if n
		(if (or (= (type n) "string") (= (type n) "list"))
			(if (= (# n) 0)
				false
				true)
			true)
		false))

;; ##### `describe a`
;; format `a` for printing.
;; --
(defn (describe x pt)
	(let ((describe-internal (λ (a)
		(if (= (type a) "list")
			(table.concat (map a (λ (x) (describe x false))) ", ")
			(if (= (type a) "pair")
				(string.format "%s . %s" (describe (head a) false) (describe (nth 2 a) false))
				(if (= (type a) "hashmap")
					(string.match (tostring a) "table: 0x(%w+)")
					(tostring a)))))))
		(if pt
			(string.format "%s: %s" (type x) (describe-internal x))
			(describe-internal x))))

;; ##### `type a`
;; reimplementation of Lua's `type`
;; --
(let ((old-type type))
	(defn (type a)
		(if (= (old-type a) "table")
			(if (= (lua-raw "a._type") "hashmap")
				"hashmap"
				(if (= (# a) 2)
					"pair"
					"list"))
				(old-type a))))

;; ##### `pair? a`
;; returns true if a is a pair
;; --
(defn (pair? a)
	(= (# a) 2))

;; ##### `eq? a b`
;; returns true if both parameters are equal
;; --

;; ##### `neq? a b`
;; returns true if both parameters are not equal
;; --
(defn (eq? a b)
	(if (or (= (type a) "function") (= (type b) "function"))
		false
		(let ((list-equals (λ (a b)
			(let ((ret true))
				(if (= (# a) (# b))
					(for i 1 (# a)
						(if (!= (nth i a) (nth i b))
							(set! ret false !global))))
					ret))))
			(if (or (= (type a) "pair") (= (type a) "list"))
				(list-equals a b)
				(= a b)))))

(defn (neq? a b)
	(not (eq? a b)))


;; ##### `nth num list`
;; get num-th element of list
;; --
(defn (nth n l)
	(if (= n 1)
		(head l)
		(nth (- n 1) (tail l))))

;; ##### `null? list`
;; returns true if list is empty.
;; --
(defn (null? lst)
	(if lst
		(= (# lst) 0)
		false))

;; ##### `foldl func accum lst`
;; combine elements of a list into an accumulator using a function.
;; --
(defn (foldl func accum lst)
	(if (null? lst)
		accum
		(foldl func (func accum (head lst)) (tail lst))))

(set! reduce foldl)

;; ##### `truth?`
;; returns true if x is truthy, or:
;; - if x is a pair, return if the first element is truthy
;; - if x is a list, return if all elements are truthy.
;; --

(defn (truth? x)
	(if (= (type x) "pair")
		(truth? (head x))
		(if (= (type x) "list")
			(let ((ret true))
				(map x (λ (n)
					(if (not n)
						(set! ret false !global))))
				ret)
			(if x
				true
				false))))
