;;@doc prelude.md

;; prelude
;; =======
;; import this if you want anything to work
;; --

;; ## Symbols
;; ##### `*standard-output*`
;; global symbol bound to the stdout stream
;; --
(def *standard-output* (io/output))

;; ##### `*version*`
;; global symbol bound to the Lua version currently in use, and the semver version of the compiler itself
;; --
(def *version* (string/format "%s - %s" _VERSION "Café v1.0.0"))

;;@version 5.1 eq
;;@warn Compiling for Lua 5.1: Copying unpack to table/unpack
(def table/unpack unpack :global)
;;@end

;; ## Functions

;; ##### `exit-on-error! erfmt ...` or `fail ...`
;; exits with a formatted error message and status code 1.
;; --
(defn (exit-with-error! erfmt ...)
	(print (string/format erfmt ...))
	(os/exit 1))
(def fail exit-with-error!)

;; ##### `print! stream string`
;; print a string to a stream
;; --
(defn (print! stream something)
	(with (choose-stream (λ (s) (if s s (io/output))))
		(with (stream (choose-stream stream))
			(.stream write something "\n"))))

;; ##### `print! stream fmtstr va_args`
;; print a formatted string to a stream
;; --
(defn (print-formatted! stream fmtstr ...)
	(print! stream (.fmtstr format ...)))

;; #### `format! fmtstr va_args`
;; print a formatted string to *standard-output* unconditionally
;; --
(defn (format! fmtstr ...)
	(print-formatted! *standard-output* fmtstr ...))

;; ##### `cons list elem`
;; cons an element in front of a list
;; --
(defn (cons car cdr)
	(list car cdr))

;; ##### `head list`
;; return the first element of a list
;; --
(defn (head li)
	(if li
		(if (or (= "list" (type li)) (= "pair" (type li)))
			li[1]
			li)
		nil))

;; ##### `list`
;; create a list from given values
;; --
(defn (list ...) {...})

;; ##### `push! car rest`
;; insert a value at the head of a list, mutating it.
;; --
(defn (push-head! car rest)
	(table/insert rest 1 car)
	rest)

;; ##### `push-tail! end rest`
;; insert a value at the end of a list, mutating it.
;; --
(defn (push-tail! fin rest)
	(table/insert rest fin)
	rest)

;; ##### `tail list`
;; return the rest of the list, without head
;; --
(defn (tail l)
	(with (ret (list))
		(for i 2 (# l)
			(push-tail! l[i] ret))

		(if (> (# ret) 1)
			ret
			(do
				(if (= "list" (type ret))
					(head ret)
					ret)))))

;; ##### `map list fn`
;; modify a list using a function, returning a new list
;; --
(defn (map li fn)
	(with (ret (list))
		(for i 1 (# li)
			(push-tail! (fn (nth i li)) ret))
		ret))

;; ##### `size li`
;; determine the size of a list.
;; --
(defn (size li)
	(with (size 0)
		(map li (λ ()
			(def size (+ 1 size) :global)))
		size))

;; ##### `filter list fn`
;; filter a list using a predicate.
;; --
(defn (filter li fn)
	(with (ret (list))
		(for i 1 (# li)
			(if (truth? (fn (nth i li)))
				(push-tail! (nth i li) ret)))
		ret))

;; ##### `curry fna fnb`
;; merge two functions together
;; --

(defn (curry a b)
	(λ (...)
		(b (a ...))))

;; ##### `exists thing`
;; returns false if:
;; - thing is a table or a string and thing.length is 0
;; - thing is falsy (false, nil)
;;
;; if not, returns true.
;; --
(defn (exists? n)
	(if n
		(if (or (= (type n) "string") (= (type n) "list"))
			(if (= (# n) 0)
				false
				true)
			true)
		false))

;; ##### `describe a`
;; format `a` for printing.
;; --
(defn (describe x pt)
	(with (describe-internal (λ (a)
		(if (= (type a) "list")
			(table/concat (map a (λ (x) (describe x false))) ", ")
			(if (= (type a) "pair")
				(string/format "%s . %s" (describe (head a) false) (describe (nth 2 a) false))
				(if (= (type a) "hashmap")
					(string/match (tostring a) "table: 0x(%w+)")
					(tostring a))))))
		(if pt
			(string/format "%s: %s" (type x) (describe-internal x))
			(describe-internal x))))

;; ##### `type a`
;; reimplementation of Lua's `type`
;; --
(with (old-type type)
	(defn (type a)
		(if (= (old-type a) "table")
			(if (= (lua-raw "a._type") "hashmap")
				"hashmap"
				(if (= (# a) 2)
					"pair"
					"list"))
				(old-type a))))

;; ##### `pair? a`
;; returns true if a is a pair
;; --
(defn (pair? a)
	(= (# a) 2))

;; ##### `pair? a`
;; returns true if a is a list
;; --
(defn (list? a)
	(= "list" (type a)))

;; ##### `eq? a b`
;; returns true if both parameters are equal
;; --

;; ##### `neq? a b`
;; returns true if both parameters are not equal
;; --
(defn (eq? a b)
	(if (or (= (type a) "function") (= (type b) "function"))
		false
		(with (list-equals (λ (a b)
			(with (ret true)
				(if (= (# a) (# b))
					(for i 1 (# a)
						(if (!= (nth i a) (nth i b))
							(def ret false :global))))
					ret)))
			(if (or (= (type a) "pair") (= (type a) "list"))
				(list-equals a b)
				(= a b)))))

(defn (neq? a b)
	(not (eq? a b)))


;; ##### `nth num list`
;; get num-th element of list
;; --
(defn (nth n l)
	(if (= n 1)
		(head l)
		(nth (- n 1) (tail l))))

;; ##### `null? list`
;; returns true if list is empty.
;; --
(defn (empty? lst)
	(cond lst
		([list,pair,hashmap] (= (# lst) 0))
		(_ true)))
(def null? empty?)

;; ##### `foldl func accum lst`
;; combine elements of a list into an accumulator using a function.
;; --
(defn (foldl func accum lst)
	(if (null? lst)
		(cond lst
			([~list] (func accum lst))
			(_ accum))
		(foldl func (func accum (head lst)) (tail lst))))

(def reduce foldl)

(defn (foldr func fin lst)
	(if (null? lst)
		fin
		(func (head lst) (foldr func fin (tail lst)))))

;; ##### `truth?`
;; returns true if x is truthy, or:
;; - if x is a pair, return if the first element is truthy
;; - if x is a list, return if all elements are truthy.
;; --

(defn (truth? x)
	(if (= (type x) "pair")
		(truth? (head x))
		(if (= (type x) "list")
			(with (ret true)
				(map x (λ (n)
					(if (not n)
						(def ret false :global))))
				ret)
			(?? x false))))

(defn (flip x)
	(λ (a b)
		(x b a)))

; Operators

(defn (^= x y)   (lua-raw "return x == y"))
(defn (^!= x y)  (lua-raw "return x ~= y"))
(defn (^> x y)   (lua-raw "return x > y"))
(defn (^< x y)   (lua-raw "return x < y"))
(defn (^not x)   (lua-raw "return not x"))

(defn (^and x y ...)
	(if (> (# args) 2)
		(foldl ^and (head args) (tail args))
		(lua-raw "return x and y")))
(defn (^or x y ...)
	(if (> (# args) 2)
		(foldl ^or (head args) (tail args))
		(lua-raw "return x or y")))
(defn (^+ x y ...)
	(if (> (# args) 2)
		(foldl ^+ (head args) (tail args))
		(cond x
			([string] (lua-raw "return x .. y"))
			(_        (lua-raw "return x + y")))))
(defn (^- x y ...)
	(if (> (# args) 2)
		(foldl ^- (head args) (tail args))
		(lua-raw "return x - y")))
(defn (^* x y ...)
	(if (> (# args) 2)
		(foldl ^* (head args) (tail args))
		(lua-raw "return x * y")))
(defn (^/ x y ...)
	(if (> (# args) 2)
		(foldl ^/ (head args) (tail args))
		(lua-raw "return x / y")))
(defn (^% x y ...)
	(if (> (# args) 2)
		(foldl ^% (head args) (tail args))
		(lua-raw "return x % y")))
(defn (^^ x y ...)
	(if (> (# args) 2)
		(foldl ^^ (head args) (tail args))
		(lua-raw "return x ^ y")))
(defn (^# y)     (lua-raw "return #y"))
(def ^?? ^or :global)

;;@version 5.3
(defn (^>> x y ...)
	(if (> (# args) 2)
		(foldl ^>> (head args) (tail args))
		(lua-raw "return x >> y")))
(defn (^<< x y ...)
	(if (> (# args) 2)
		(foldl ^<< (head args) (tail args))
		(lua-raw "return x << y")))
(defn (^| x y ...)
	(if (> (# args) 2)
		(foldl ^| (head args) (tail args))
		(lua-raw "return x | y")))
(defn (^& x y ...)
	(if (> (# args) 2)
		(foldl ^& (head args) (tail args))
		(lua-raw "return x & y")))

(defn (^~ y)     (lua-raw "return ~y"))

(defn (^>= x y)  (lua-raw "return x >= y"))
(defn (^<= x y)  (lua-raw "return x <= y"))

;;@else
;;@warn Compiling without support for bitwise operators!
;;@end

(defn (range fin)
	(if (= fin 0)
		(list)
		(cons fin (range (- fin 1)))))
