;;@doc prelude.md

;; prelude
;; =======
;; import this if you want anything to work
;; --

;; ## Symbols
;; ##### `*standard-output*`
;; global symbol bound to the stdout stream
;; --
(def *standard-output* io/stdout)
;; ##### `*standard-error*`
;; global symbol bound to the stderr stream
;; --
(def *standard-error* io/stderr)
;; ##### `*standard-input*`
;; global symbol bound to the stdin stream
;; --
(def *standard-input* io/stdin)
;; ##### `*version*`
;; global symbol bound to the Lua version currently in use, and the semver version of the compiler itself
;; --
(def *version* (string/format "%s - %s" _VERSION "Café v1.0.0"))

;;@version 5.1 eq
;;@warn Compiling for Lua 5.1: Copying unpack to table/unpack
(def table/unpack unpack :global)
;;@end

;; ## Functions

;; ##### `exit-on-error! erfmt ...` or `fail ...`
;; exits with a formatted error message and status code 1.
;; --
(defn (exit-with-error! erfmt ...)
	(print (string/format erfmt ...))
	(os/exit 1))
(def fail exit-with-error!)

;; ##### `print! stream string`
;; print a string to a stream
;; --
(defn (print! stream something)
	(with (choose-stream (λ (s) (if s s (io/output))))
		(with (stream (choose-stream stream))
			(.stream write something "\n"))))

;; ##### `print! stream fmtstr va_args`
;; print a formatted string to a stream
;; --
(defn (print-formatted! stream fmtstr ...)
	(print! stream (.fmtstr format ...)))

;; #### `format! fmtstr va_args`
;; print a formatted string to *standard-output* unconditionally
;; --
(defn (format! fmtstr ...)
	(print-formatted! *standard-output* fmtstr ...))

;; ##### `cons list elem`
;; cons an element in front of a list
;; --
(defn (cons car cdr)
	(cond cdr
		([list,pair] '(car (table/unpack cdr)))
		(_ (list car cdr))))

;; ##### `head list`
;; return the first element of a list
;; --
(defn (head li)
	(if li
		(if (or (= "list" (type li)) (= "pair" (type li)))
			li[1]
			li)
		nil))

;; ##### `list`
;; create a list from given values
;; --
(defn (list ...) args)

;; ##### `push! car rest`
;; insert a value at the head of a list, mutating it.
;; --
(defn (push-head! car rest)
	(table/insert rest 1 car)
	rest)

;; ##### `! end rest`
;; insert a value at the end of a list, mutating it.
;; --
(defn (push-tail! fin rest)
	(table/insert rest fin)
	rest)

;; ##### `tail list`
;; return the rest of the list, without head
;; --
(defn (tail l)
	(with (ret '())
		(for i 2 (# l)
			(push-tail! l[i] ret))
		(if (> (# ret) 1)
			ret
			(do
				(if (= "list" (type ret))
					(head ret)
					ret)))))

;; ##### `map list fn`
;; modify a list using a function, returning a new list
;; --
(defn (map li fn)
	(cond li
		([list] (with (ret '())
			(for i 1 (# li)
				(push-tail! (fn (nth i li)) ret))
			ret))
		([function] (with (ret '())
			(for i 1 (# fn)
				(push-tail! (li (nth i fn)) ret))
			ret))))
;; ##### `size li`
;; determine the size of a list.
;; --
(defn (size li)
	(with (size 0)
		(map li (λ ()
			(def size (+ 1 size) :global)))
		size))

;; ##### `filter list fn`
;; filter a list using a predicate.
;; --
(defn (filter li f)
	(cond li
		([list|0|] (do (print "edge case") '()))
		(_ li)
		([list|x:xs|]
			(do
				(cond x
					((f x) (x . (filter xs f)))
					(_ (filter xs f)))))))

;; ##### `curry fna fnb`
;; merge two functions together, applying the second over the result of the first
;; --

(defn (curry a b)
	(λ (...) (b (a ...))))

;; ##### `compose fna fnb`
;; merge two functions together, applying the first over the result of the second
;; --

(defn (compose a b)
	(λ (...) (a (b ...))))

;; ##### `exists thing`
;; returns false if:
;; - thing is a table or a string and thing.length is 0
;; - thing is falsy (false, nil)
;;
;; if not, returns true.
;; --
(defn (exists? n)
	(if n
		(if (or (= (type n) "string") (= (type n) "list"))
			(if (= (# n) 0)
				false
				true)
			true)
		false))

;; ##### `describe a`
;; format `a` for printing.
;; --
(defn (describe x pt)
	(defn (describe-list list)
		(defn (dli accum elem)
			(+ (describe-internal accum) ", " (describe-internal elem)))
		(foldl dli (describe-internal (head list)) (tail list)))
	(defn (describe-internal a)
		(cond a
			([list] (string/format "(%s)" (describe-list a)))
			([pair] (string/format "%s . %s" (describe (head a) false) (describe (nth 2 a) false)))
			([hashmap] (string/format "hm(%s)" (string/match (tostring a) "table: 0x(%w+)")))
			([function] (string/format "fn(%s)" (string/match (tostring a) "function: 0x(%w+)")))
			(_ (tostring a))))
		(if pt
			(string/format "%s: %s" (type x) (describe-internal x))
			(describe-internal x)))

;; ##### `type a`
;; reimplementation of Lua's `type`
;; --
(with (old-type type)
	(defn (type a)
		(if (= (old-type a) "table")
			(if (= (lua-raw "a._type") "hashmap")
				"hashmap"
					"list")
				(old-type a))))

;; ##### `pair? a`
;; returns true if a is a pair
;; --
(defn (pair? a)
	(= (# a) 2))

;; ##### `pair? a`
;; returns true if a is a list
;; --
(defn (list? a)
	(= "list" (type a)))

;; ##### `eq? a b`
;; returns true if both parameters are equal
;; --

;; ##### `neq? a b`
;; returns true if both parameters are not equal
;; --
(defn (eq? a b)
	(if (or (= (type a) "function") (= (type b) "function"))
		false
		(with (list-equals (λ (a b)
			(with (ret true)
				(if (= (# a) (# b))
					(for i 1 (# a)
						(if (!= (nth i a) (nth i b))
							(def ret false :global))))
					ret)))
			(if (or (= (type a) "pair") (= (type a) "list"))
				(list-equals a b)
				(= a b)))))

(defn (neq? a b)
	(not (eq? a b)))


;; ##### `nth num list`
;; get num-th element of list
;; --
(defn (nth n l)
	(if (= n 1)
		(head l)
		(nth (- n 1) (tail l))))

;; ##### `null? list`
;; returns true if list is empty.
;; --
(defn (empty? lst)
	(cond lst
		([list,pair,hashmap] (= (# lst) 0))
		(_ true)))
(def null? empty?)

;; ##### `foldl func accum lst`
;; combine elements of a list into an accumulator using a function.
;; --
(defn (foldl func accum lst)
	(if (null? lst)
		(cond lst
			([~list] (func accum lst))
			(_ accum))
		(foldl func (func accum (head lst)) (tail lst))))

(def reduce foldl)

(defn (foldr func fin lst)
	(if (null? lst)
		fin
		(func (head lst) (foldr func fin (tail lst)))))

;; ##### `truth?`
;; returns true if x is truthy, or:
;; - if x is a pair, return if the first element is truthy
;; - if x is a list, return if all elements are truthy.
;; --

(defn (truth? x)
	(if (= (type x) "pair")
		(truth? (head x))
		(if (= (type x) "list")
			(with (ret true)
				(map x (λ (n)
					(if (not n)
						(def ret false :global))))
				ret)
			(?? x false))))

; Operators

(defn (^= x y)   (lua-raw "return x == y"))
(defn (^!= x y)  (lua-raw "return x ~= y"))
(defn (^> x y)   (lua-raw "return x > y"))
(defn (^< x y)   (lua-raw "return x < y"))
(defn (^not x)   (lua-raw "return not x"))

(defn (^and x y ...)
	(if (> (# args) 2)
		(foldl ^and (head args) (tail args))
		(lua-raw "return x and y")))
(defn (^or x y ...)
	(if (> (# args) 2)
		(foldl ^or (head args) (tail args))
		(lua-raw "return x or y")))

(defn (^+ x y ...)
	(if (> (# args) 2)
		(foldl ^+ (head args) (tail args))
		(cond x
			([string] (lua-raw "return x .. y"))
			([list]
				(cond y
					([list] (join x y))
					(_ (push-tail! y x))))
			(_ (lua-raw "return x + y")))))

(defn (^- x y ...)
	(if (> (# args) 2)
		(foldl ^- (head args) (tail args))
		(lua-raw "return x - y")))
(defn (^* x y ...)
	(if (> (# args) 2)
		(foldl ^* (head args) (tail args))
		(lua-raw "return x * y")))
(defn (^/ x y ...)
	(if (> (# args) 2)
		(foldl ^/ (head args) (tail args))
		(lua-raw "return x / y")))
(defn (^% x y ...)
	(if (> (# args) 2)
		(foldl ^% (head args) (tail args))
		(lua-raw "return x % y")))
(defn (^^ x y ...)
	(if (> (# args) 2)
		(foldl ^^ (head args) (tail args))
		(lua-raw "return x ^ y")))
(defn (^# y)     (lua-raw "return #y"))
(def ^?? ^or :global)

;;@version 5.3 eq
(defn (^>> x y ...)
	(if (> (# args) 2)
		(foldl ^>> (head args) (tail args))
		(lua-raw "return x >> y")))
(defn (^<< x y ...)
	(if (> (# args) 2)
		(foldl ^<< (head args) (tail args))
		(lua-raw "return x << y")))
(defn (^| x y ...)
	(if (> (# args) 2)
		(foldl ^| (head args) (tail args))
		(lua-raw "return x | y")))
(defn (^& x y ...)
	(if (> (# args) 2)
		(foldl ^& (head args) (tail args))
		(lua-raw "return x & y")))

(defn (^~ y)     (lua-raw "return ~y"))

(defn (^>= x y)  (lua-raw "return x >= y"))
(defn (^<= x y)  (lua-raw "return x <= y"))

;;@else
;;@warn Compiling without support for bitwise operators!
;;@end

;; ### `range end`
;; create a list of integers from 0 to `end`
;; --
(defn (range fin)
	(if (= fin 0)
		'()
		(fin . (range (- fin 1)))))

;; ### `partial fn x`
;; return a function that when invoked applies the given function (`fn`) with parameters `x` and parameters given to the return function.
;; --
(defn (partial fn x)
	(λ (y) (fn x y)))

;; ### `flip x`
;; return a function that when invoked applies the given function (`x`) with it's parameters in reverse order.
(defn (flip x)
	(λ (a b) (x b a)))

;; ### `elem? a li`
;; return true if `a` is an element of `li`, false otherwise.
;; --
(defn (elem? a li)
	(cond li
		([list|0|] false)
		([list|x:xs|]
			(if (= x a) true
				(elem? a xs)))
		((eq? a li) true)
		(_ false)))

;; ### `join li1 li2`
;; join the two given lists
;; --
(defn (join li1 li2)
	(with (ret (copy li1))
		(map li2 (λ (x) (push-tail! x ret)))
		ret))

;; ### `copy li1`
;; copy a list
;; --
(defn (copy li1)
	(with (ret '())
		(map li1 (λ (x)
			(push-tail! x ret)))
		ret))
