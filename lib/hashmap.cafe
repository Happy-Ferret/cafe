(defn (hash-map/new ...)
	(let ((l (list ...)) (ret (list)) (skip false))
		(for i 1 (# l)
			(if (not skip)
				(if (and (nth i l) (nth (+ 1 i) l))
					(lua-raw "ret[l[i]] = l[i + 1]; skip = true"))
				(def skip false :global)))
	(lua-raw "ret._type = 'hashmap'")
	ret))

(defn (hash-map/empty)
	(with (ret (list))
		(lua-raw "ret._type = 'hashmap'")
		ret))

(defn (hash-map/map hm fun)
	(with (ret (hash-map/empty))
		(lua-raw "for k, v in pairs(hm) do")
			(if (neq? (.k sub 1 1) "_")
				(lua-raw "ret[k] = fun(v, k)"))
		(lua-raw "end")
		ret))

(defn (hash-map/filter hm fun)
	(with (ret (hash-map/empty))
		(lua-raw "for k, v in pairs(hm) do")
			(if (neq? (.k sub 1 1) "_")
				(lua-raw "ret[k] = fun(v, k)"))
		(lua-raw "end")
		ret))

(defn (hash-map/size hm)
	(with (accum 0)
		(hash-map/map hm (Î» ()
			(def accum (+ 1 accum) :global)))
		accum))

(defn (hash-map/set hm k v)
	(lua-raw "hm[k] = v"))

(defn (hash-map/get hm k v)
	(lua-raw "return hm[k] or v"))
